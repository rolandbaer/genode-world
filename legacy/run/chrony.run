#
# \brief  Test for using chrony
# \author Roland Baer
# \date   2021-12-29
#
# Note: To get a recent certificate run the following command on a linux system
#       with openssl installed:
# $ openssl s_client -showcerts ptbtime1.ptb.de:4460 </dev/null
#       From the given output select the certificate from Let's Encrypt
#       (or whatever is the root of the given certificate chain).
#
# This run-script attempts to download the current .crt and to make it
# available as ROM automatically.
#

#
# For the moment limit the tested platforms as the test might
# take a few minutes to finish, even in the good case.
#
assert {[have_spec x86_64]}
assert {[have_board pc]}
assert {[have_spec nova] || [have_spec hw]}

create_boot_directory

import_from_depot [depot_user]/src/[base_src] \
                  [depot_user]/pkg/[drivers_nic_pkg] \
                  [depot_user]/pkg/system_rtc-[board] \
                  [depot_user]/src/gmp \
                  [depot_user]/src/init \
                  [depot_user]/src/libc \
                  [depot_user]/src/nic_router \
                  [depot_user]/src/posix \
                  [depot_user]/src/stdcxx \
                  [depot_user]/src/vfs \
                  [depot_user]/src/vfs_jitterentropy \
                  [depot_user]/src/vfs_lxip \
                  [depot_user]/src/vfs_pipe \
                  [depot_user]/src/nettle/3.7-2025-10-01 \
                  [depot_user]/src/gnutls/3.6.16-2025-10-02 \
                  [depot_user]/src/chrony/4.6.1-2025-10-02

proc rtc_driver { } {
	switch [board] {
		linux   { return "linux_rtc" }
		pc      { return "pc_rtc" }
		default { return "dummy_rtc" }
	}
}

#
# Generate config
#

set lx_ip_addr "10.0.2.55"

append config {
<config verbose="yes" prio_levels="2">
	<parent-provides>
		<service name="ROM"/>
		<service name="IRQ"/>
		<service name="IO_MEM"/>
		<service name="IO_PORT"/>
		<service name="PD"/>
		<service name="RM"/>
		<service name="CPU"/>
		<service name="LOG"/>
	</parent-provides>
	<default-route>
		<any-service> <parent/> <any-child/> </any-service>
	</default-route>
	<default caps="100" ram="1M"/>

	<start name="timer">
		<provides> <service name="Timer"/> </provides>
	</start>

	<start name="nic" caps="1500" ram="32M" managing_system="yes">
		<binary name="init"/>
		<route>
			<service name="ROM" label="config"> <parent label="drivers.config"/> </service>
			<service name="Timer"> <child name="timer"/> </service>
			<service name="Uplink"> <child name="nic_router"/> </service>
			<any-service> <parent/> </any-service>
		</route>
	</start>

	<start name="report_rom">
		<provides> <service name="Report"/> <service name="ROM"/> </provides>
		<config verbose="yes">
			<policy label_suffix="set_rtc" report="chrony_daemon -> set_rtc"/>
		</config>
	</start>

	<start name="rtc" ld="} [expr [have_board linux] ? "no" : "yes"] {">
		<binary name="} [rtc_driver] {"/>
		<config verbose="yes" allow_setting_rtc="yes" />
		<provides> <service name="Rtc"/> </provides>
		<route>
			<service name="Timer"> <child name="timer"/> </service>
			<service name="ROM" label="set_rtc"> <child name="report_rom"/> </service>
			<any-service> <parent /> </any-service>
		</route>
	</start>
}

append config {
	<start name="nic_router" caps="120" ram="5M">
		<provides> <service name="Nic"/> <service name="Uplink"/> </provides>
		<config>
			<policy label_prefix="chrony_daemon" domain="server"/>
			<policy label_prefix="nic"           domain="uplink"/>
			<domain name="uplink" }
append_if [have_spec linux] config " interface=\"$lx_ip_addr/24\" gateway=\"10.0.2.1\""
append config { >
				<nat domain="server" tcp-ports="16384" udp-ports="16384" icmp-ids="16384"/>
			</domain>
			<domain name="server" interface="10.0.3.1/24" verbose_packets="yes">
				<tcp dst="0.0.0.0/0"><permit-any domain="uplink" /></tcp>
				<udp dst="0.0.0.0/0"><permit-any domain="uplink" /></udp>
				<dhcp-server ip_first="10.0.3.2" ip_last="10.0.3.3" ip_lease_time_sec="600">
					<dns-server ip="8.8.8.8" />
				</dhcp-server>
			</domain>
		</config>
	</start>

	<start name="system_rtc">
		<provides><service name="Rtc"/></provides>
		<config verbose="yes" allow_setting_rtc="true"/>
		<route>
			<service name="ROM" label="set_rtc"> <child name="report_rom"/> </service>
			<service name="Timer"> <child name="timer"/> </service>
			<service name="Rtc"> <child name="rtc"/> </service>
			<any-service> <parent/> </any-service>
		</route>
	</start>
}

append config {
	<start name="chrony_daemon" caps="320" ram="64M" priority="-1">
		<binary name="chronyd"/>
		<config ld_verbose="yes" verbose="yes">
			<env key="GNUTLS_DEBUG_LEVEL" value="10" />
			<arg value="chronyd"/>
			<arg value="-d"/>
			<arg value="-d"/>
			<arg value="-4"/>
			<libc stdout="/dev/log" stderr="/dev/log" rtc="/dev/rtc" socket="/socket" pipe="/pipe" rng="/dev/random" />
			<vfs>
				<dir name="dev">
					<log/>
					<jitterentropy name="random"/>
					<jitterentropy name="urandom"/>
					<rtc/>
					<null/>
				</dir>
				<dir name="socket">
					<lxip dhcp="yes"/>
				</dir>
				<dir name="pipe"> <pipe/> </dir>
				<dir name="etc">
					<inline name="chrony.conf">
server ptbtime1.ptb.de nts
ntstrustedcerts /etc/cert_lets_encrypt.crt
makestep 1.0 3
rtcsync
driftfile /var/run/chrony/drift
logdir /var/log
log tracking
</inline>
					<!-- see note on top to update certificate -->
					<rom name="cert_lets_encrypt.crt"/>
				</dir>
				<dir name="var">
					<dir name="run">
						<dir name="chrony">
							<inline name="chronyd.pid"></inline>
							<inline name="chronyd.sock"></inline>
							<inline name="drift"></inline>
						</dir>
					</dir>
					<dir name="log">
						<inline name="tracking.log" />
					</dir>
				</dir>
			</vfs>
		</config>
		<route>
			<service name="Nic">   <child name="nic_router"/> </service>
			<service name="Timer"> <child name="timer"/>      </service>
			<service name="Rtc">   <child name="system_rtc"/> </service>
			<any-service> <parent/> <any-child/> </any-service>
		</route>
	</start>
</config>
}

install_config $config

#
# These three awk rules print all lines of the second certificate,
# including '-----BEGIN...' and '-----END...'. The first rule enables
# dumping, while the second flags the end of the certificate block.
# The third rules prints all lines belonging to the certificate and
# disables dumping in case the end flag is set.
#
exec openssl s_client -showcerts ptbtime1.ptb.de:4460 </dev/null 2> /dev/null | \
     awk "/BEGIN/ {end=0; cert++; if(cert == 2) dump=1} /END/ {end=1} {if(dump) print \$0; if(end) dump=0}" \
     > bin/cert_lets_encrypt.crt

build_boot_image [list {*}[build_artifacts] cert_lets_encrypt.crt]

#
# Execute test case
#

# qemu config
append qemu_args "  -nographic "

append_qemu_nic_args "hostfwd=tcp::12865-:12865,hostfwd=tcp::49153-:49153"

run_genode_until {.*init -> rtc] set time to.*} 600
